# SDD + TDD ワークフローガイドライン（汎用テンプレート）

## 背景と問題

従来の仕様書は以下の問題がある：
- 計画を仕様書として永続化 → 更新コストが高い
- コード例が豊富 → 実装と乖離
- 技術層別に分離（DB/API/Frontend）→ 参照が分散

**注意**: 「決定事項のみ」は失敗した方針。仕様書を薄くしすぎると実装不能になる。

## 新しい仕様書の方針

**目標**: 人間が見て「何をどう実装するか」が分かり、AIが実装計画を動的生成できる情報量

**含めるべき情報**:
- 要件（What）: ユーザーができること
- 設計判断（Why）: なぜその方法を選んだか
- データ: テーブル定義、enum、アソシエーション
- データ送受信: フォームパラメータ、エンドポイント、JSON形式の例（API時）
- **UI動作**: 画面構成、操作フロー、遷移
- **演出**: トリガー、演出内容、タイミング（ms単位）
- 実装状況: チェックリスト

**含めないもの**:
- コマンド例（rails g model...）
- 詳細なコード実装（コードがSource of Truth）
- タイムライン（Day 1, Day 2...）

## 仕様書構造

プロジェクトの性質に応じて、以下のいずれかの構造を採用。**Phase 0 で決定し、architecture.md に記録**。

### パターンA: UI中心のアプリケーション（推奨）

画面単位で仕様を整理。Webアプリ、モバイルアプリ等に適している。

```
docs/specs/
├── architecture.md      # 技術スタック・設計判断
├── roadmap.md           # タスク一覧・進捗管理
├── data.md              # ER図・モデル定義
├── animations.md        # 全画面共通の演出仕様（必要な場合）
└── screens/             # 画面単位
    └── [画面名].md
```

### パターンB: バックエンド/API中心

機能単位で仕様を整理。REST API、GraphQL API等に適している。

```
docs/specs/
├── architecture.md
├── roadmap.md
├── data.md
└── features/            # 機能単位
    └── [機能名].md
```

### パターンC: 複雑なワークフロー

ユーザーストーリー単位で仕様を整理。複数画面にまたがる処理が多い場合に適している。

```
docs/specs/
├── architecture.md
├── roadmap.md
├── data.md
└── stories/             # ストーリー単位
    └── [ストーリー名].md
```

**重要**: プロジェクト内では構造を統一すること。

## ロードマップの構造

```markdown
## Phase N: カテゴリ名
| 状態 | タスク | 仕様書 |
|------|--------|--------|
| ✅ | タスク名 | `screens/xxx.md` or `features/xxx.md` or `stories/xxx.md` |
| ⬜ | タスク名 | `screens/xxx.md` or `features/xxx.md` or `stories/xxx.md` |
```

- 参照先をファイル単位で明示（セクションまでは不要）
- 依存関係を図で可視化
- 参照先は選択した仕様書構造（screens/features/stories）に合わせる

## 仕様書のテンプレート

**重要**: 仕様書は「実装に必要十分な情報」を含むこと。

以下は画面仕様（パターンA）の例。機能仕様（パターンB）、ストーリー仕様（パターンC）も同様の構造を適用。

~~~markdown
# タイトル（画面名/機能名/ストーリー名）

概要説明（1-2行）

---

## 画面構成

| 要素 | 説明 |
|------|------|
| 背景 | 説明 |
| 要素1 | 説明（上から下へ順序よく） |
| 要素2 | 説明 |

---

## 入力フィールド（入力がある画面のみ）

| フィールド | 必須 | 制約 | 説明 |
|------------|------|------|------|
| フィールド名 | ○ | 制約内容 | 説明 |

制約詳細は `data.md` 参照。

---

## UI動作

### 操作カテゴリ

| 操作 | 動作 |
|------|------|
| クリック | 動作説明 |

---

## エラーハンドリング

| 状況 | 対応 |
|------|------|
| エラー種別 | 対応内容 |

---

## データ送受信

### フォーム送信の場合

**アクション**: `POST /xxx`

**パラメータ**:
- param1: 説明
- param2: 説明

**リダイレクト先**: 成功時の遷移先

### API通信の場合

**エンドポイント**: `GET /api/v1/xxx`

**レスポンス（成功: 200）**:
```json
{ "key": "value" }
```

---

## 演出

`animations.md` 参照。（演出がある場合）

- 演出1
- 演出2

---

## 実装状況

### バックエンド

- [ ] コントローラアクション (xxxController#action)
- [ ] モデル・バリデーション
- [ ] ビュー (ERB/JSON/etc.)
- [ ] サービスクラス（必要に応じて）

### フロントエンド

- [ ] 画面表示
- [ ] データ送受信（フォーム送信/API連携）
- [ ] UI動作実装
- [ ] エラーハンドリング
- [ ] 演出・アニメーション

**Note**: プロトタイプ実装状況を記載（あれば）。
~~~

## 変更管理ルール

| 変更の種類 | 仕様書更新 | コード更新 |
|-----------|-----------|-----------|
| 要件変更（What） | ✅ | ✅ |
| 設計判断変更（Why） | ✅ | ✅ |
| 実装詳細変更（How） | ❌ 不要 | ✅ |
| バグ修正 | ❌ 不要 | ✅ |

## ワークフロー

### プロジェクト立ち上げ（Phase 0）

新規プロジェクト開始時のフロー。仕様書が存在しない状態から開始。

**前提**: 要件定義書はユーザーが作成済み

```
要件定義書（ユーザー作成）
    ↓
要件定義書の整理（AI + ユーザー）
    ↓
仕様書作成（AI作成、ユーザー承認）
    ↓
各機能の実装（繰り返し）
```

#### Step 1: 要件定義書の確認と整理

- ユーザーに要件定義書の場所を確認
- 全体像を把握（機能一覧、世界観、制約）
- 不明点はユーザーに質問
- **要件定義書の整理**（ユーザーと協力）:
  - 冗長な記述の軽量化
  - 構造の最適化（機能単位、優先度明確化）
  - 曖昧な要件の明確化

#### Step 1.5: プロトタイプ作成（任意）

**Step 1 完了後、AIがユーザーに確認する。** スキップ可能。

UIの動作確認が必要な場合、プロトタイプを作成する。

```
要件定義書
    ↓↑ イテレーション（ユーザー承認まで）
プロトタイプ
```

- 要件をUIで確認
- フィードバックを要件定義書に反映
- ユーザー承認で Step 2 へ進む

#### Step 2: プロトタイプの確認

- 実装済み機能の把握
- 演出の動作確認
- 使用アセット（画像・音声）の確認

※ファイル構成の整理は Step 3 / 実装フェーズで行う

#### Step 3: architecture.md 作成

以下を決定・記録：

| 項目 | 内容 |
|------|------|
| 技術スタック | 言語、フレームワーク、DB等 |
| 設計判断 | 選定理由 |
| **仕様書構造** | **screens/ or features/ or stories/ （パターンA/B/Cから選択）** |
| ディレクトリ構成 | レイヤー別パス |
| フロントエンド構成 | JS/CSS分割、共通関数 |
| データ送受信パターン | フォーム送信パターン、API連携パターン（fetchラッパー）等 |
| アセット一覧 | 画像・音声（用途付き） |
| エンドポイント一覧 | コントローラアクション一覧（概要のみ） |
| テスト方針 | TDD、E2E、カバレッジ目標 |

#### Step 3.5: data.md 作成

要件定義書からデータ構造を抽出・設計：

1. **ER図作成**
   - 要件定義書から登場するエンティティを洗い出し
   - 関連を整理（1対多、多対多）
   - mermaid形式で記述

2. **モデル定義**
   - 各モデルのカラム定義（型、制約、デフォルト値）
   - バリデーション（必須、長さ制限、フォーマット）
   - アソシエーション
   - enum値の定義

3. **LocalStorage仕様**（必要な場合）
   - キー名と用途
   - データ構造
   - ライフサイクル

#### Step 3.6: animations.md 作成（演出がある場合）

要件定義書から演出を抽出・整理：

1. **全画面共通演出の抽出**
   - 画面構成（ビューポート、共通レイアウト等）
   - 質感演出
   - 汎用演出（画面遷移、ボタンクリック等）

2. **画面別演出の整理**
   - 各画面で使用される演出を列挙
   - トリガー条件を明記
   - 演出内容と時間（ms単位）を記載
   - SE名をアセットリストと照合

3. **演出の構造化**
   - フェーズ分け（Step 1, 2, 3...）
   - 各フェーズの時間と内容
   - 使用するSE

#### Step 4: roadmap.md 作成

1. 機能を洗い出し
2. 依存関係を整理
3. Phaseに分割（基盤 → モデル → バックエンド → UI → 演出 → 仕上げ）
4. 各タスクに参照先（screens/*.md）を紐づけ

```markdown
## Phase N: カテゴリ名
| 状態 | タスク | 仕様書 |
|------|--------|--------|
| ⬜ | タスク名 | `screens/xxx.md` or `features/xxx.md` or `stories/xxx.md` |
```

#### Step 5: 仕様書ファイル作成

選択した構造（screens/features/stories）に従って仕様書を作成。情報源を明確にして抽出・設計する。

##### 情報源と抽出方法

| セクション | 情報源 | 方法 |
|-----------|--------|------|
| 画面構成 | 要件定義書 | 直接抽出（上から下へ順序よく） |
| 入力フィールド | 要件定義書 + `data.md` | 要件から基本情報、data.mdから制約詳細を参照 |
| UI動作 | 要件定義書 + AI設計 | 要件から概要抽出、AIが詳細設計（debounce、LocalStorageキー名等） |
| エラーハンドリング | AI設計 | 標準的なエラー対応を設計（バリデーション、通信エラー） |
| データ送受信 | AI設計 + `data.md` 参照 | フォーム設計 or API設計（data.mdのモデルから構造設計） |
| 演出 | `animations.md` 参照 | 演出リストを参照形式で記載（演出がある場合） |
| 実装状況 | 要件定義書から推測 | バックエンドとフロントエンドに分けてチェックリスト化 |

##### AI設計時のガイドライン

**データ送受信設計:**
- **フォーム送信の場合**: form_for/form_with の設計、Strong Parameters
- **API通信の場合**: RESTful命名規則（`GET /api/v1/resources` 等）、JSON構造設計
- `data.md` のモデル定義から構造を設計
- リクエスト・レスポンス両方の例を記載（API時）
- ステータスコードを明記（API時: 200, 201, 204, 422等）

**エラーハンドリング:**
- バリデーションエラー: エラーメッセージ表示
- 通信エラー: フォールバック処理（フォーム再表示、LocalStorage退避、リトライ等）
- エラーメッセージは `config/locales/ja.yml` 参照と明記

**UI動作の詳細:**
- debounce等のパフォーマンス最適化（標準: 300ms）
- LocalStorageキー名の命名規則（スネークケース推奨）
- SE再生タイミングの明記（演出がある場合）

#### Step 6: ユーザー承認

作成した仕様書をユーザーに提示し、承認を得る。
**承認なしに実装フェーズへ進んではいけない。**

---

### 各機能の実装（繰り返し）
1. `roadmap.md` で次のタスクと参照先を確認
2. 仕様書（`screens/*.md` or `features/*.md` or `stories/*.md`）で仕様を確認
3. コードベースを分析（SerenaMCP）
4. 複雑な機能時は feature-dev プラグインを活用
5. 実装計画を動的生成（永続化しない）
6. ユーザー承認
7. TDD実装（Red → Green → Refactor）
8. レビュー（バックエンド: rails-reviewer / フロントエンド: code-reviewer）
9. `roadmap.md` の状態を更新

### feature-dev プラグインの活用

| サブエージェント | 役割 | 使用タイミング |
|-----------------|------|---------------|
| `code-explorer` | 既存コードの深い分析 | 新機能が既存コードと関わる時 |
| `code-architect` | 実装設計の作成 | 複雑な機能、複数ファイルに跨る時 |
| `code-reviewer` | コードレビュー | 全ての実装後（特にフロントエンド） |

### フロントエンドのテスト方針

- **バックエンド**: TDD（RSpec）
- **フロントエンド**: 手動確認 + System Spec（E2E）

**System Spec（Capybara）で確認**: 画面遷移、データ送受信、主要ユーザーフロー
**手動確認**: 演出・アニメーション、レスポンシブ、ブラウザ互換性

## 原則

- **仕様書 = 実装に必要十分な情報**（What/Why + UI動作/演出タイミング）
- **コード = 実装詳細**（How - コードがSource of Truth）
- **計画は動的生成**（永続化しない）
- **テストが仕様の証明**（TDD）

### 仕様書の品質チェックリスト
- [ ] 人間が読んで「何を実装するか」が分かるか
- [ ] AIが実装計画を動的生成できる情報量があるか
- [ ] 画面構成が上から下へ順序よく記載されているか
- [ ] 入力フィールドが記載されているか（入力がある画面のみ）
- [ ] UI動作が記載されているか（操作 → 動作）
- [ ] 演出がanimations.md参照になっているか（演出がある場合）
- [ ] データ送受信仕様が記載されているか（フォームパラメータ or JSON例）
- [ ] エラーハンドリングが記載されているか
