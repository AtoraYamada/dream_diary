# SDD + TDD ワークフローガイドライン

## 背景と問題

従来の仕様書（5743行）は以下の問題があった：
- 計画を仕様書として永続化 → 更新コストが高い
- コード例が豊富 → 実装と乖離
- 技術層別に分離（DB/API/Frontend）→ 参照が分散

**注意**: 「決定事項のみ」は失敗した方針。仕様書を薄くしすぎると実装不能になる。

## 新しい仕様書の方針

**目標**: 人間が見て「何をどう実装するか」が分かり、AIが実装計画を動的生成できる情報量

**含めるべき情報**:
- 要件（What）: ユーザーができること
- 設計判断（Why）: なぜその方法を選んだか
- データ: テーブル定義、enum、アソシエーション
- API: エンドポイント、JSON形式の例
- **UI動作**: 画面構成、操作フロー、遷移
- **演出**: トリガー、演出内容、タイミング（ms単位）
- 実装状況: チェックリスト

**含めないもの**:
- コマンド例（rails g model...）
- 詳細なコード実装（コードがSource of Truth）
- タイムライン（Day 1, Day 2...）

## 仕様書構造

```
docs/specs/
├── architecture.md      # 技術スタック・設計判断
├── roadmap.md           # タスク一覧・進捗管理
├── data.md              # ER図・モデル定義
├── animations.md        # 全画面共通の演出仕様
├── sdd_workflow_guidelines.md  # 本ファイル
└── screens/
    ├── top.md           # トップ画面
    ├── auth.md          # 認証画面
    ├── library.md       # 書斎（メインハブ）
    ├── list.md          # 一覧画面（本棚）
    ├── create.md        # 作成画面
    ├── detail.md        # 詳細画面
    ├── edit.md          # 編集画面
    ├── search.md        # 検索画面（索引箱）
    └── overflow.md      # 夢の氾濫（特殊演出）
```

## ロードマップの構造

```markdown
## Phase N: カテゴリ名
| 状態 | タスク | 仕様書 |
|------|--------|--------|
| ✅ | タスク名 | `screens/xxx.md` |
| ⬜ | タスク名 | `screens/xxx.md` |
```

- 参照先をファイル単位で明示（セクションまでは不要）
- 依存関係を図で可視化

## 画面仕様のテンプレート

**重要**: 仕様書は「実装に必要十分な情報」を含むこと。

~~~markdown
# 画面名（サブタイトル）

概要説明（1-2行）

---

## 画面構成

| 要素 | 説明 |
|------|------|
| 背景 | 説明 |
| 要素1 | 説明（上から下へ順序よく） |
| 要素2 | 説明 |

---

## 入力フィールド（入力がある画面のみ）

| フィールド | 必須 | 制約 | 説明 |
|------------|------|------|------|
| フィールド名 | ○ | 制約内容 | 説明 |

制約詳細は `data.md` 参照。

---

## UI動作

### 操作カテゴリ

| 操作 | 動作 |
|------|------|
| クリック | 動作説明 |

---

## エラーハンドリング

エラーメッセージは `config/locales/ja.yml` 参照。

| 状況 | 対応 |
|------|------|
| エラー種別 | 対応内容 |

---

## API

### API名

**エンドポイント**: `GET /api/v1/xxx`

**レスポンス（成功: 200）**:
```json
{ "key": "value" }
```

---

## 演出

`animations.md` 参照。

- 演出1
- 演出2

---

## 実装状況

### バックエンド（API）

- [ ] GET /api/v1/xxx (controller名)
- [ ] POST /api/v1/xxx (controller名)
- [ ] Jbuilderビュー (xxx.json.jbuilder)

### フロントエンド

- [ ] 画面表示
- [ ] API連携
- [ ] UI動作実装
- [ ] エラーハンドリング
- [ ] 演出・SE再生

**Note**: プロトタイプ実装状況を記載（あれば）。
~~~

## 変更管理ルール

| 変更の種類 | 仕様書更新 | コード更新 |
|-----------|-----------|-----------|
| 要件変更（What） | ✅ | ✅ |
| 設計判断変更（Why） | ✅ | ✅ |
| 実装詳細変更（How） | ❌ 不要 | ✅ |
| バグ修正 | ❌ 不要 | ✅ |

## ワークフロー

### プロジェクト立ち上げ（Phase 0）

新規プロジェクト開始時のフロー。仕様書が存在しない状態から開始。

**前提**: 要件定義書はユーザーが作成済み

```
要件定義書（ユーザー作成）
    ↓
要件定義書の整理（AI + ユーザー）
    ↓
仕様書作成（AI作成、ユーザー承認）
    ↓
各機能の実装（繰り返し）
```

#### Step 1: 要件定義書の確認と整理

- ユーザーに要件定義書の場所を確認
- 全体像を把握（機能一覧、世界観、制約）
- 不明点はユーザーに質問
- **要件定義書の整理**（ユーザーと協力）:
  - 冗長な記述の軽量化
  - 構造の最適化（機能単位、優先度明確化）
  - 曖昧な要件の明確化

#### Step 1.5: プロトタイプ作成（任意）

**Step 1 完了後、AIがユーザーに確認する。** スキップ可能。

UIの動作確認が必要な場合、プロトタイプを作成する。

```
要件定義書
    ↓↑ イテレーション（ユーザー承認まで）
プロトタイプ
```

- 要件をUIで確認
- フィードバックを要件定義書に反映
- ユーザー承認で Step 2 へ進む

#### Step 2: プロトタイプの確認

- 実装済み機能の把握
- 演出の動作確認
- 使用アセット（画像・音声）の確認

※ファイル構成の整理は Step 3 / 実装フェーズで行う

#### Step 3: architecture.md 作成

以下を決定・記録：

| 項目 | 内容 |
|------|------|
| 技術スタック | 言語、フレームワーク、DB等 |
| 設計判断 | 選定理由 |
| ディレクトリ構成 | レイヤー別パス |
| フロントエンド構成 | JS/CSS分割、共通関数 |
| API連携パターン | fetchラッパー等 |
| アセット一覧 | 画像・音声（用途付き） |
| API一覧 | エンドポイント一覧（概要のみ） |
| テスト方針 | TDD、E2E、カバレッジ目標 |

#### Step 3.5: data.md 作成

要件定義書からデータ構造を抽出・設計：

1. **ER図作成**
   - 要件定義書から登場するエンティティを洗い出し
   - 関連を整理（1対多、多対多）
   - mermaid形式で記述

2. **モデル定義**
   - 各モデルのカラム定義（型、制約、デフォルト値）
   - バリデーション（必須、長さ制限、フォーマット）
   - アソシエーション
   - enum値の定義

3. **LocalStorage仕様**（必要な場合）
   - キー名と用途
   - データ構造
   - ライフサイクル

#### Step 3.6: animations.md 作成

要件定義書から演出を抽出・整理：

1. **全画面共通演出の抽出**
   - 画面構成（4:3ビューポート、額縁等）
   - 質感演出（PS1フィルタ等）
   - 汎用演出（瞬き、選択・決定、画面スライド等）

2. **画面別演出の整理**
   - 各画面で使用される演出を列挙
   - トリガー条件を明記
   - 演出内容と時間（ms単位）を記載
   - SE名をアセットリストと照合

3. **演出の構造化**
   - フェーズ分け（Step 1, 2, 3...）
   - 各フェーズの時間と内容
   - 使用するSE

#### Step 4: roadmap.md 作成

1. 機能を洗い出し
2. 依存関係を整理
3. Phaseに分割（基盤 → モデル → API → UI → 演出 → 仕上げ）
4. 各タスクに参照先（screens/*.md）を紐づけ

```markdown
## Phase N: カテゴリ名
| 状態 | タスク | 仕様書 |
|------|--------|--------|
| ⬜ | タスク名 | `screens/xxx.md` |
```

#### Step 5: screens/*.md 作成

各画面の仕様書を作成。情報源を明確にして抽出・設計する。

##### 情報源と抽出方法

| セクション | 情報源 | 方法 |
|-----------|--------|------|
| 画面構成 | 要件定義書 | 直接抽出（上から下へ順序よく） |
| 入力フィールド | 要件定義書 + `data.md` | 要件から基本情報、data.mdから制約詳細を参照 |
| UI動作 | 要件定義書 + AI設計 | 要件から概要抽出、AIが詳細設計（debounce、LocalStorageキー名等） |
| エラーハンドリング | AI設計 | 標準的なエラー対応を設計（バリデーション、通信エラー） |
| API | AI設計 + `data.md` 参照 | RESTful命名規則に従い、data.mdのモデルからJSON設計 |
| 演出 | `animations.md` 参照 | 演出リストを参照形式で記載 |
| 実装状況 | 要件定義書から推測 | バックエンド（API）とフロントエンドに分けてチェックリスト化 |

##### AI設計時のガイドライン

**API設計:**
- RESTful命名規則（`GET /api/v1/resources`, `POST /api/v1/resources` 等）
- `data.md` のモデル定義からJSON構造を設計
- リクエスト・レスポンス両方の例を記載
- ステータスコードを明記（200, 201, 204, 422等）

**エラーハンドリング:**
- バリデーションエラー: エラーメッセージ表示
- 通信エラー: フォールバック処理（LocalStorage退避、リトライ等）
- エラーメッセージは `config/locales/ja.yml` 参照と明記

**UI動作の詳細:**
- debounce等のパフォーマンス最適化（標準: 300ms）
- LocalStorageキー名の命名規則（スネークケース推奨）
- SE再生タイミングの明記

#### Step 6: ユーザー承認

作成した仕様書をユーザーに提示し、承認を得る。
**承認なしに実装フェーズへ進んではいけない。**

---

### 各機能の実装（繰り返し）
1. `roadmap.md` で次のタスクと参照先を確認
2. `screens/*.md` で仕様を確認
3. コードベースを分析（SerenaMCP）
4. 複雑な機能時は feature-dev プラグインを活用
5. 実装計画を動的生成（永続化しない）
6. ユーザー承認
7. TDD実装（Red → Green → Refactor）
8. レビュー（バックエンド: rails-reviewer / フロントエンド: code-reviewer）
9. `roadmap.md` の状態を更新

### feature-dev プラグインの活用

| サブエージェント | 役割 | 使用タイミング |
|-----------------|------|---------------|
| `code-explorer` | 既存コードの深い分析 | 新機能が既存コードと関わる時 |
| `code-architect` | 実装設計の作成 | 複雑な機能、複数ファイルに跨る時 |
| `code-reviewer` | コードレビュー | 全ての実装後（特にフロントエンド） |

### フロントエンドのテスト方針

- **バックエンド（API）**: TDD（RSpec）
- **フロントエンド**: 手動確認 + System Spec（E2E）

**System Spec（Capybara）で確認**: 画面遷移、API連携、主要ユーザーフロー
**手動確認**: 演出・アニメーション、レスポンシブ、ブラウザ互換性

## 原則

- **仕様書 = 実装に必要十分な情報**（What/Why + UI動作/演出タイミング）
- **コード = 実装詳細**（How - コードがSource of Truth）
- **計画は動的生成**（永続化しない）
- **テストが仕様の証明**（TDD）

### 仕様書の品質チェックリスト
- [ ] 人間が読んで「何を実装するか」が分かるか
- [ ] AIが実装計画を動的生成できる情報量があるか
- [ ] 画面構成が上から下へ順序よく記載されているか
- [ ] 入力フィールドが記載されているか（入力がある画面のみ）
- [ ] UI動作が記載されているか（操作 → 動作）
- [ ] 演出がanimations.md参照になっているか
- [ ] API仕様がJSON例付きで記載されているか
- [ ] エラーハンドリングが記載されているか
